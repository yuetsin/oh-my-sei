# OO 设计建模

## 设计建模

要得到三个模型：

* 对象模型（核心）
* 动态模型
* 功能模型

## 构件图

对「类」进行更高层次的封装，产生「可重用」的构件。

* 构件在功能上需要自包含、紧密耦合、能完成独立功能
	* 「最小完备集」原则
* 具有明确的接口可以被重用
* 可配置、可组装

## 部署图

定义系统的执行架构，即如何将软件制品分配到不同的节点上去运行。

主要需要考虑的问题有：

* 节点（Node）
* 软件制品（部署在节点上的信息、数据、代码）
* 通信链路（节点之间如何通信？）

## 状态机图

* 状态
	* 满足一组不变式条件的状态
	* 用圆角矩形表示
	* 特别地有，起始状态、结束状态用黑点表示
* 转移
	* 状态之间的路径变化
* 事件
	* 触发状态之间的迁移

## 类设计

### 原则

* 单一职责

每个类应该只有一个职责。否则多个职责之间会产生紧耦合、降低内聚性。

* Liskov 替换规则

在用到继承的时候，务必问自己：是否可替换？

即，如果 B 继承自 A，那么是否任何 A 出现的地方，皆可用 B 正确替换？

> Liskov 替换规则：子类必须能够替换父类。

* 依赖倒置原则

高层模块不应依赖于底层模块，而是依赖于他们之间的抽象。

抽象不应该依赖实现细节，细节应该依赖于抽象。

* 接口隔离原则

> 依赖倒置原则说，类与类之间的依赖应该仅限于接口。但是「接口」的粒度有多细，它并没有说明。

接口隔离原则说，客户端不应该被迫依赖他们用不到的接口；累与泪之间的关系应该建立在最小的接口之上。

即，接口的职责越单一越好、越细化越好。

* 开放 − 关闭原则

软件实体（类、模块、函数等等）应该对扩展开放，但是对修改关闭。

即，应当允许基于实体进行功能的扩展，例如

```swift
extension UIImage {
    func doSomethingVeryFunny() -> UIImage {
        // ...
        return self
    }
}
```

应该被允许，然而修改其原本的属性、行为则应该被阻止。

```swift
extension Integer {
    override func operator+(const Integer other) -> Integer {
        return self - other
    }
}
```

像这种修改就令人不安，而且会引发灾难。

### 如何设计类

* 创建设计类
* 定义操作（抽象地考虑这个类需要做什么、唯一职责是？）
* 定义方法（为了使操作可行，需要哪些具体的方法？）
* 定义状态（抽象地，考虑类的状态）
* 定义属性（为了描述状态，需要哪些实际的属性？）
* 定义依赖（这个类依赖于其他哪些类？）
* 定义关联（聚合、组合、导向、多重、关联？）

