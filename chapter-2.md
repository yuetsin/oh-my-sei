# 软件过程

## 定义

* 软件过程：1984 年 10 月召开第一节国际软件过程会议并提出概念。
* 全程「软件生存周期过程」。
* 软件生命周期：某软件从构想出现开始，到最后一次被使用之间的周期。

## 模型

### 瀑布模型

> 线性模型）

* 流程：需求分析、设计、实现、测试、交付、使用和维护。
* 问题：不支持需求变更、错误发现太晚、开发进度慢。

### 增量模型

> 有计划的产品改进模型）

* 从一组给定的需求开始，构造一系列可执行的版本来开发。
* 每个新版本都纳入一部分需求，直到最后开发完成。
* 只进行一次需求分析和架构设计，但每次发布都进行设计、实现、测试、交付。
* 多版本可以并发进行，且每个版本都可以运行。
* 但问题：仍然不支持需求变更（只在最开始进行一次需求分析）。

### 演化模型

> 渐进式开发）

* 给出初始需求
* 进行设计、实现、测试
* 根据维护请求确定更多的需求
* 再次进行设计（回到 Step 2），进行迭代
* 直到某一次不再有更多需求前来，交付完整产品
* 好处：允许变更需求（等下一次迭代就可以），且允许不明确的初始需求

* 常见的两种演化模型：原型模型、螺旋模型。
* 原则一：每次迭代都能产生一个可以发布的版本。
	* 每次迭代的过程：迭代规划、需求分析、设计、实现、测试、发布。
	* 区别：允许（鼓励）其中部分并行。
* 原则二：必须有计划的迭代，而不是胡来。
	* 即，可以看到上面的「迭代过程」里有特别的一项「迭代规划」。

#### 原型模型

原型，就是在具体实现之前的 Demo / Prototype。
* 需求分析
* 原型开发、原型评价
* 交给用户获得反馈，回到需求分析
* 获得认可后再进行最终系统设计、最终系统实现。
	* 如果最终实现和原型实现完全独立，即原型在验证完成後被抛弃，则称为「抛弃式原型」。
	* 如果在「原型」的基础上进行最终系统的实现，则称为「演化式原型」。
* 问题：原型可能给人不切实际的想象，造成预算的爆炸。

#### 螺旋模型

融合了原型（演化式）和迭代的模型。
* 按照迭代开发的方式进行开发，只不过一开始不要求实现可发布功能，而是将其作为「原型」给用户。
* 这样，原型和成品之间的界限被模糊了，规避了原型模型带来的问题。

## UP

统一软件过程（Unified Process）。
* 风险驱动、基于 UML、构建式架构。
* 四大阶段：先启（Inception）、精化（Elaboration）、构建（Construction）、产品化（Transition）。
* 每个阶段都细分成若干个迭代。
	* 增量式迭代：风险小时采用，逐步进行。
	* 演进式迭代：风险大时采用，多次探索。
	* 增量提交：难度不大、但需求老变时采用。
	* 单次迭代：退化成瀑布模型。

### Agile

敏捷过程（Agile Software Development）。
* 在这样的情况下比较合适采用：
	* 需求不确定、易挥发
	* 开发人员责任感强、积极向上
	* 用户能参与、能沟通
	* 团队小于 10 人众
* 自下而上提出的敏捷过程。

Agile 有这么几种子过程：

#### XP

极限编程（eXtreme Programming）。
* 首先开发出最重要的特性，迅速提供用户要求的功能。
* 结对编程（几秒钟）
* 单元测试（几分钟）
* 结对磋商（几小时）
* 站立会议（一天）
* 验收测试（几天）
* 迭代计划（几周）
* 发布计划（几个月）
* 省略掉了「系统和架构」这一步骤，编码和设计同时进行，因此特别强调测试。
* 弱化了未来需求的设计，注重当前状态的简化。

#### Scrum 编程

* 关注敏捷软件开发的管理。
* 自我管理、迭代开发。

#### MSF（Microsoft Solutions Framework）

* 微软的。


