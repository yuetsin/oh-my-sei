# 软件建模

## 模型

对客观世界的简化。对事物、系统的抽象描述。

这里我们只讨论「软件模型」。

### 层次

* CIM，计算无关模型。
* PIM，平台无关模型。
* PSM，平台相关模型。

软件开发中，首先由 CIM 得到 PIM、再得到 PSM、最后得到代码。

## 建模

### 结构化方法

模块化思想，自顶向下，逐步求精。

由三部分组成。

#### 结构化分析

输出一个结构化分析模型。

* 核心：数据字典（DD）。系统涉及的各种数据对象的总和。
* 根据 DD 可以画出…
* ERD（实体 − 关系图），描述数据对象之间的关系。
* DFD（数据流图），指明数据是如何流动变化的。
* STD（状态 − 变迁图），表明了系统在外部事件下的动作和状态变迁。

#### 结构化设计

* Fan-in（扇入）高，代表上级模块多，可以增加模块的利用率；
* Fan-out（扇出）低，代表下级模块少，可以减少模块调用和控制的复杂度。
	* 增加中间层可以降低扇出。
* 设计良好的软件应该像是「瓮」形，两头小中间大。

#### 结构化编程

* 采用顺序、选择、重复基本控制结构来构造程序
* 避免使用 `goto` 语句
	* Dijkstra 如是说

#### 结构化语言

* 判定表。
	* 首先，列出所有条件的对象。
	* 然后，列出个条件对象的取值（组合）。
	* 最后，把每一种组合对应采取的动作写出。
* 判定树
	* 类似，只不过是用「树」形结构来标记不同条件的取值分歧罢了。

### 面向对象方法

> 不是「面向对象编程」（OOP）。

Object-Oriented Method。UML 的提出，使得其变成了主流方法。

#### 概念

* 对象（Object）

	* 现实世界中个体、事物的抽象表示。
	* 属性、和方法（动作）的包装体。

* 类（Class）

	* 某些对象之间的共同特征。
	* 对象是类的实例（Instance）。

* 继承（Inheritance）

	* 一种类之间的关系。
	* 根据 Liskov 替换规则定义：衍生類別（子類）物件可以在程式中代替其基礎類別（超類）物件。

* 消息（Message）

	* 对象与其他世界关联的唯一途径。
	* 对象向其他对象发送消息以请求服务、响应其他对象传来的消息。

	> Smalltalk 大法好

#### 原则

* 抽象（Abstraction）
	* 世界那么复杂。
	* 通过抽象，反映出事物最主要的、本质的、显著的特征。
* 封装（Encapsulation）
	* 将对象的特征隐藏在黑盒之中。
	* 对外仅仅保留公共接口。
* 模块化（Modularity）
	* 将整个软件划分为独立命名、处理的模块。
	* 模块组合起来能够满足功能需求。
* 层次（Hierarchy）
	* 不同级别的抽象组成的树状结构。

#### 面向对象分析（OO Analysis）

* 了解问题领域所涉及的对象；
* 分析对象之间的关系和作用（操作）；
* 构造问题的分析模型。

#### 面向对象设计（OO Design）

建立在 OOA 的基础上，可以进行软件的设计。

OOA 是独立于具体的实现的。

但是 OOD 就和具体的平台、实现挂钩了。

### 面向服务方法

Service Oriented Method。

#### 架构

* 服务注册中心
	* 保存着目前系统内所有服务的描述及调用接口。
* 服务提供者
	* 前往注册中心将自己注册（发布）。
* 服务消费者
	* 向服务注册中心查找服务描述，并和服务提供者进行绑定、调用。

#### 特征

* 松散耦合

服务之间耦合度肯定很低很低——因为中间插了一层抽象（服务注册中心）。

* 位置透明

服务的位置对调用者来说并不重要。还是因为那一层抽象。

* 协议无关

具体实现可能会让服务提供者和服务消费者直接绑定连接，而是由服务中心提供 ESB 总线来负责交互。

这样，ESB 通过各种协议适配器就可以实现协议转换啦。

#### 实现

「服务」是个上层抽象——「独立完成某件任务」的最小单元。

服务由「构件」来实现。服务和构件并不是一对一的关系。或许有一个服务由多个构件共同完成，又或许一个构件同时支撑多个服务。

在构件的实现之下，就是我们熟悉的 OOM——对象、类等等东西。

### 模型驱动

Model Driven Development（MDD）。

写代码现在，不直接写，而是先建模（用 UML 等语言），然后通过模型生成代码的编码方式。

> 实验室现在就在做这种项目…

## 数据流图

DFD。

* 圆形：加工（要进行的动作）。
* 箭头：数据的流动方向。数据的名称总是标在箭头的边上。
* 方框：数据的源头和归宿（与系统交互的人、外界系统）。
* 双杠：数据库、数据文件。

DFD 可以分层。例如，0 层（顶层）DFD 中的某一个节点在下一层 DFD 中可能就包含更多内部加工（动作），有更多的数据流动、内部数据文件等等。

不过注意，每个节点深层 DFD 的「外部数据输入输出」必须和其上层 DFD 中对应节点的输入边、输出边保持一致。

> 细化建模不能改变其上层结构。

## 数据字典

DD。

每一种流动的数据具有什么样的结构？数据字典来描述。

用下面的结构化语言：

* `x = ...`，代表 `x` 由 `...` 组成
* `a + b`，表示 `a` 和 `b`
* `[a, b]`（`[a | b]`）表示 `a` 或 `b`。
* $\{a\}$，表示 $a$ 重复若干次。
* $\{a\}_m^n$，表示 $a$ 重复 $a$ 到 $b$ 次。省略 $m$ 或 $n$，代表不设下/上限。
* $(a)$，等价于 $\{a\}_0^1$，即可选——出现 0 次或 1 次。
* `"..."`，用引号扩起来代表基本数据元素。

对数据流中每一种数据都逐一写出定义，就能汇编出数据字典啦。

## 结构化设计

任务：把 DFD（分析模型）转换成用 SC（结构图）表示的设计模型。

DFD 又分为两种：变换型（输入、变换、输出）、事务性（一或多条输入路径、一个事务中心，若干条动作路径）。

首先，在 DFD 中区分出输入、事务中心（变换中心）和输出三部分，并且在 DFD 中标出分界线。

然后，进行若干次分解。先建立一个主控模块，再从主控模块中分出下层部分功能模块。如果说某一模块仍有子模块，继续在下一层分隔。

输入输出同样用一个模块包裹。所有实际的输入、输出工作在叶子结点中完成。

> 注意，从 DFD 中的节点到 SC 中的节点只是映射而已。

然后，将 DFD 中的数据流在 SC 中的树状结构中写出来。

因为其中肯定包含很多多层转发（例如，从树的一个叶子到另一个叶子），所以重复写「数据结构」的名字就太复杂了。一般用数字来表示，在右下角写出图例，比较简便。

