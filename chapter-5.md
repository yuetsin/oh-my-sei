# 面向对象分析建模

## 用例图

### 概览

* 从黑盒角度出发；
* 描述谁（什么）与系统交互；
* 外部世界希望他做什么。

### 包括

* 执行者（Actor）
	* 与系统交互的实体，可以是人、外设、系统；
	* 一个用例图可能会涉及到多个执行者。
* 用例（Use Case）
	* 用椭圆形来表示一个用例；
	* 代表执行者希望系统为他们做什么；
	* 每一个用例显然需要对应一个执行者；
	* 站在执行者的观点来看，**用例必须是一个完整的活动流程**，为执行者提供价值。
* 关系
	* 执行者和用例之间的关系；（唯一关系：关联，即某一执行者利用某一用例）
	* 用例和用例之间的关系；（包含关系、扩展关系、泛化关系）
	* 执行者和执行者之间的关系。（唯一关系：泛化。即，某一类执行者是另一类执行者的泛化）

## 活动图

### 概览

* 刻画一个（子）系统的工作流程；
* 描述用例内部的事件流。

### 包括

* 动作（行为的基本单元，多个动作组成一整个行为）；

* 控制流（从一个动作向另一个动作的有向边，表明动作控制权的转移）；

* 控制节点（协调动作的节点，决定活动流的流程）。

	* 初始节点（Initial Node），是活动的入口；（实心圆）
	* 终止节点（Final Node），是活动的结束；（十字叉圆）
	* 判断节点（Decision Node），根据某个条件选择不同的控制流往下流（只是选择一条）；（菱形符号）
	* 合并节点（Merge Node），多条控制流「殊途同归」（流到这里都同样地向下走）；（菱形符号）
	* 分叉节点（Fork Node），并发流。分出的执行流需要并发执行；（一条粗横线）
	* 汇合节点（Join Node），直到所有传入流都执行完成，再继续向下转移控制流。（一条粗横线）

	> 注意区分「判断、合并」节点和「分叉、汇合」节点的区别。

## 类图

### 类

给出「类的名字」、「类的属性（每个属性的名字 + 类型）」、「类的操作」，就算是定义了一种「类」。

属性、操作前面可以加入符号来修订其可见性：

* `+`，代表 `public`（和 C++ 一致）
* `-`，代表 `private`（和 C++ 一致）
* `#`，代表 `protected`（和 C++ 一致）
* `~`，代表 `package`（可以被同一个包内的不同进程访问，当然也就包含了继承自她的类）

就封装性来说，`public` > `protected` > `package` > `private`。

Java 中有 `package` 可见性等级，就是在不使用任何 `public`、`private`、`protected` 关键字修饰时的默认情况。

### 继承（Inheritance）

用一个空心三角形箭头，由派生类指向基类。

注意，继承是非常强有力的关系，所谓「`is a`」。

Liskov 替换规则：如果 B 继承自 A，那么所有 A 出现的地方，皆应可以用 B 合法地替换。这和语言中的 `is a` 略有区别，请留意。

### 关联（Association）

两个相对独立的类 A、B，在 A 的特定实例和 B 的特定实例存在固定关系时，就构成一种关联关系。

### 聚合（Aggregation）

一类特殊的关联，构成「部分与整体」的关系，即每个 A 都包含一部分 B（但他们还是独立存在），就组成这种聚合关系。

用空菱形箭头来表示。菱形靠近整体，箭头靠近部分。

![img](chapter-5.assets/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTExLzIxLzBfMTMyMTg4NjY0OW5CQjcuZ2lm.jpeg)

### 组合（Composition）

非常强形式的聚合，即整体和部分具有相同的生命周期。无法脱离彼此而存在。

用实菱形箭头来表示。菱形靠近整体，箭头靠近部分。

![img](chapter-5.assets/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTExLzIxLzBfMTMyMTg4NjY1OUFFNkMuZ2lm.jpeg)

这两张图应该能明确地体现出 Aggregation 和 Composition 的区别了。

关键在于：是否允许脱离整体的部分存在。

### 依赖（Dependency）

用虚线箭头表示。由依赖方指向被依赖方，并且在虚线上写出双尖括号包围的依赖详情。

依赖是临时的、非结构型的关系。

> 分析阶段几乎不使用依赖来分析。

## 时序图

左上角写出图名。

纵轴写出所有涉及到的角色。

然后，从上到下画出「从入口（调用）」指向某个角色，进行内部处理後返回的时间流。

注意，正常的调用都用实线箭头；同步的返回用虚线箭头指回调用者；异步的返回一般省略（如果要画出来还是要用实线的）。

## 通信图

各个模块之间通信的方式。

简单——画出各个模块，然后把时序图里的箭头都搬过来就行。

不过注意，时序图里可以根据 y 轴高低来判断通信发生的先后；但是摊平了的通信图看不出来。

所以要在每条箭头上标注好调用的函数、以及次序（数字编号）。

## 包图

上面那么多图，显然放一起会很乱。

所以我们一般按照功能拆分成包（Package）。

显然包里面保存的图存在依赖关系，所以包之间也有依赖关系。用虚线箭头画出。

注意，不允许包之间存在循环依赖。在分包的时候就要留意，不能让这样的事情发生。