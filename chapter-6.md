# 设计工程

## 包括

* 架构设计（概要设计）
	* 定义软件的全貌
	* 记录最重要的设计决策
	* 随后的设计、实现的战略指导
* 详细设计（构件级设计）
	* 定义各个模块的内部细节
	* 一般每个决策只影响单个模块的实现
	* 用于指导随后的编码工作

## 模型

软件设计模型和实现直接相关，因此是平台依赖模型（PSM）。

相比于分析模型，设计模型有这些区别：

* 分析模型平台无关（PIM），设计模型平台依赖（PSM）。
* 分析模型面向问题空间，设计模型面向解空间。
* 分析模型是外向行为的刻画，设计模型关注内向结构细节。
* 分析模型是功能性需求的反映；设计模型是非功能性需求的反映。
* 分析模型比较简单，设计模型比较复杂。

## 目标

* 实现所有（明确的和隐含的）需求。
* 容易读、容易理解。
* 提供软件的全貌，从实现的角度阐明数据域、功能域、行为域。

## 工具

视不同的软件开发方法而定，由不同的工具用来进行设计工程。

例如，结构化方法就用结构图（SC）来刻画软件结构，用程序流程图（人教数学选修 3 的那种）、PAD 图、N − S 图来记录详细设计结果。

面向对象方法则采用类图、时序图、通信图、部署图、构件图、状态机图等等。

## 原则

不管采用哪种工具来进行设计工程，以下原则都需要遵守：

### 抽象

控制复杂性的基本策略之一。

三种抽象方式：

* 过程抽象（Procedural Abstraction）
	* 把完成一个特定功能的动作序列\
	* 抽象成一个过程名字和参数列表（就是函数嘛）。
	* 随后使用名字和实际参数列表对其进行调用
* 数据抽象（Data Abstraction）
	* 把一个数据对象的定义（看上面！）抽象为一个数据类型名。
	* 随后可以用这个名字来定义多个具有相同结构的数据对象。
* 对象抽象（Object Abstraction）
	* 上面两种抽象的组合。
	* 持有一定的数据结构、能够执行一组特定的操作，就构成了「对象」。

### 分解（模块化）

控制复杂性的基本策略之一。

将一个复杂的软件**自顶向下**地分解成若干个模块，并将这些模块组合起来完整系统。

将一个复杂的问题分解为几个较小的问题，通常能够减小解题所需要的工作量。
$$
C_{1 + 2} \gt C_1 + C_2
$$

### 封装（信息隐藏）

应该这样设计和封装模块，使得一个模块内包含的信息（包括成员数据和成员方法）对于不需要这些信息的模块来说是不可访问的。

> 标准定语后置翻译腔

实际上，封装信息只是手段，目的在于封装「实现细节」，只对外公开「接口」，从而分离接口与实现。

### 追求高内聚

内聚，指的是模块内部各个元素结合的紧密程度。

从弱到强地，可以将「内聚」分为这几类：

#### 低内聚

* 偶然内聚

模块共同完成一组任务，但是之间只有微弱的关系。

* 逻辑内聚

一个模块内的任务执行类似的逻辑。

* 时间内聚

一个模块内包含的任务必须在类似的时间段内执行。（如一大堆初始化）

#### 中内聚

* 过程内聚

模块内的处理元素相关，并且必须以特定的次序执行。

* 通信内聚

如果模块内的过程都仰赖同一个输入、（和/或）共同给出同一个输出，则称为「通信内聚」。

#### 高内聚

* 顺序内聚

如果一个模块内的处理元素和同一个功能密切相关，且「串联起来」，即「前一个处理元素的输出影响下一个处理元素的输入」，则称为「顺序内聚」。

* 功能内聚

如果顺序内聚的基础上，所有处理元素共同完成统一任务，则称为功能内聚。

> 最高等级的内聚。

设计时应该尽量避免低内聚，中高的都可以考虑。

### 追求低耦合

耦合，指的是不同模块之间互连程度的度量。

耦合从弱到强可以分为这几类：

#### 弱耦合

* 非直接耦合

相互之间没有任何信息传递。

* 数据耦合

通过参数表交换简单变量类型数据的耦合方式。

* 特征耦合

和数据耦合很类似，只不过交换的数据是复杂数据结构。

#### 中耦合

* 控制耦合

传输的数据不是单纯的「数据」，而是控制模块内部运行状况的「开关」、「标识量」等。

由于包含模块内部运行状况的信息，所以这种耦合度就更高。

#### 较强耦合

* 外部耦合

两个模块共同访问一个全局简单变量。

* 公共耦合

两个模块共同访问一个全局数据结构。

#### 强耦合

* 内容耦合

模块之间互相调用彼此的数据，或者存在直接的控制流转移。

> 除了内容耦合一定要避免以外，其他的耦合有时无法避免。
>
> 但是，尽量低的耦合度是更好的。

## 设计风格

### 通用

* 分层结构
	* 对高层屏蔽低层
	* 低层不依赖于高层
* 管道和过滤器结构
	* 想一想 Linux 的 Shell
* 黑板结构
	* 「黑板数据」的状态决定整个系统的控制流。

### 分布式

* 客户端 − 服务器
	* 客户端和服务器之间通过各种渠道（网络、套接字等等）异步通信
	* 服务器支持高效率的并发访问
	* 适合那些数据量很大、用户界面复杂的系统
* 三层架构
	* 表示层、业务逻辑层、数据访问层
* 代理（Broker）架构
	* 在客户端和服务器之间插入代理层
	* 屏蔽更多实现细节，增强灵活性

### 交互式

* MVC 风格
	* 模型（M）、视图（V）、控制器（C）
	* 控制器更新视图和模型。
	* 视图将用户动作发给控制器。
	* 模型在数据改变时通知控制器。
* PAC 风格
	* 表示（P）、抽象（A）、控制器（C）
	* 和 MVC 类似。只不过 PAC 是分层的、松散耦合的。

### 自适应式

* 微内核
	* 提供最小化的内核（Kernel）；
	* 用户可以通过内核扩展其功能。
* 反射
	* 引入元信息，实现动态的属性、方法增减
	* 效率大爆炸

### 其他

* 批处理
	* 管道 − 过滤器的退化风格
	* 仅仅批量执行一系列指令
	* 不存在数据的流动
* 解释器
	* IDLE 那样的。
	* 输入、解释、执行、输出 + 更新内部状态。
	* 循环执行。

## 设计模式

### 创建型

> 对实例化过程进行抽象

* 工厂

```java
public void construct(Factory concreteFactory) {
    User user = concreteFactory.createUser();
    Bid bid = concreteFactory.createBid();
    // ...
}
```

> 不行，这真是太难看了

* 构建器

将复杂对象的构建和表示分离。

```java
public void construct(Builder concreteBuilder) {
    concreteBuilder.BuildUserPack();
    concreteBuilder.BuildUser();
    concreteBuilder.BuildBid();
    UserPack userPack = concreteBuilder.getResult();
}
```

> 同样很糟糕…

* 工厂方法

可以理解成虚的构造函数…

* 原型

对于很简单的类来说，加工厂类平添层次，不好。

如果你想要的只是创建很多个超简单对象，不如就先创建好一个「原型」对象，并且对这类对象提供 `clone` 方法，其余所有的实例都从原型克隆得到。

* 单例

确保一个类只有单一一个实例，通常是这么实现的：

```python
_singleton = None

def get_singletion():
    global _singleton
    if _singleton == None:
        _singleton = CreateSingleton()
    return _singleton
```

只有真正重量级的对象才能考虑设计成单例的。

### 结构型

> 关注如何用类和对象组成更大的结构。

* 适配器

	* 将一个类的接口做包装/转换，使得他们之间可以协作。

* 桥接

	* 将类的抽象部分和实现部分分离，并在运行时刻连接起来。
	* Scott Meyers 心心念念的 Pimpl 惯用法。

* 组合

	* 表示「部分与整体」这种关系。

* 装饰器

	* 在运行时动态地将职责添加到对象之中去。

* 外观

	* 把一组子模块包装起来，只保留一部分接口对外公开，完成职责。

* 享元

	* 通过共享支持细粒度的对象。
	* 例如，对于某些对象来说，高昂的存储开销并不在于其单个对象的庞大大小，而是其数量的庞大。
	* 如果对象所能取得的数量有限，那么用少数共享对象来存储可能可以节约很多资源。
	* 典型例子：Python（和其他很多语言）的不可变字符串就可以用享元来存储。

	```python
	Python 3.9.1 (default, Dec 10 2020, 10:36:35) 
	[Clang 12.0.0 (clang-1200.0.32.27)] on darwin
	Type "help", "copyright", "credits" or "license" for more information.
	>>> a = "hello"
	>>> b = "hello"
	>>> id(a)
	4485703728
	>>> id(b)
	4485703728
	```

	* 如果字符串可变，那么就需要进行 Copy on Write 机制；多核状态下就需要加锁。这会严重影响性能，所以 C++ 的 `std::string` 就不做这种优化，而 `std::string_view` 是可以的。

* 代理

	* 根据需要创建高额对象（懒加载）
	* 提供额外的保护（隔离）
	* 执行额外的、对用户透明的操作

### 行为型

> 关注算法和对象之间的赋值

* 职责链条

	* 避免发送者和请求者之间的耦合
	* 多个对象都有机会处理请求
	* 将接受对象串成链，多个对象都有机会处理请求
	* 不用明确指定接受者

* 命令

	* 将请求封装成对象
	* 用不同的请求将其参数化
	* 支持请求排队、支持撤销操作等
	* 调用操作的对象和执行操作的对象解耦

* 解释器

	* 对给定的语言定义和文法表示\
	* 提供该语言的解释器来解释句子

* 迭代器

	* 无需暴露底层表示就能按顺序访问各个元素的方式
	* C++ 的 `iterator` 就是很好的例子；
	* 可以用统一的语法访问队列、链表、数组、etc。

* 中介器

	* 提到中介就来气

* 备忘录

	* 不破坏封装的情况下捕获对象内部状态
	* 并且可以在将来恢复状态
	* 实际上就是简单 Dump/Restore 内存块而已
	* 确实不破坏封装，也确实可以完美恢复状态
	* 就是感觉有点暴力…

* 观察者

	* 定义了对象之间的「一对多」依赖
	* 当一个对象变化时，与其关联的一堆对象都会得到通知

* 状态

	* 对象的行为因其内部状态而变化
	* …这很不 C++

* 策略

	* 对每个算法进行封装，并且可互相替换

* 模板方法

	* 跟 C++ 里面的模板不太像是一回事
	* 倒不如说和 `pure virtual` 方法有点类似
	* 把关键部分抽象成纯虚方法，同时保留公共部分

* 访问者

	* 允许在不改变对象结构的情况下，定义用于这些元素的不同操作
	* 为什么不用 `virtual` 方法 `override` 来实现？
	* 非要搞出一个新类访问者，写出

	```python
	def access(who: object):
	    if type(who) == TypeA:
	        ...
	    elif type(who) == TypeB:
	        ...
	    ...
	```

	这种垃圾代码？

